{"version":3,"file":"statechart.js","sourceRoot":"","sources":["../../src/config/statechart.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  IConfig,\n  IConfiguration,\n  IDerive,\n  filter,\n  map,\n  mutate,\n  pipe,\n} from '../'\n\nconst ACTIONS = 'ACTIONS'\nconst CHART = 'CHART'\n\nexport interface Statechart<C extends IConfiguration, S extends {\n  [state: string]: Statecharts | Statechart<any, any> | void\n}> {\n  initial: keyof S\n  states: {\n    [N in keyof S]: {\n      entry?: keyof C['actions']\n      exit?: keyof C['actions']\n      chart?: S[N],\n      on?: {\n        [N in keyof C['actions']]?:\n          | keyof S\n          | {\n              target: keyof S\n              condition: (state: C['state']) => boolean\n            }\n          | null\n      }\n    }\n  }\n}\n\ninterface Statecharts {\n  [id: string]: Statechart<any, any>\n}\n\nfunction isRootChart(chart) {\n  return ('initial' in chart && 'states' in chart)\n}\n\nfunction forceNestedCharts(charts: Statecharts | Statechart<any, any>) {\n  if (isRootChart(charts)) {\n    charts = { [CHART]: charts } as Statecharts\n  }\n\n  return Object.keys(charts).reduce((aggr, chartKey) => {\n    aggr[chartKey] = {\n      ...charts[chartKey],\n      states: Object.keys(charts[chartKey].states).reduce((statesAggr, stateKey) => {\n        if (charts[chartKey].states[stateKey].chart) {\n          statesAggr[stateKey] = {\n            ...charts[chartKey].states[stateKey],\n            chart: forceNestedCharts(charts[chartKey].states[stateKey].chart)\n          }\n        } else {\n          statesAggr[stateKey] = charts[chartKey].states[stateKey]\n        }\n  \n        return statesAggr\n      }, {})\n    }\n\n    return aggr\n  }, {})\n}\n\nfunction getActionTransitions(\n  actionName: string,\n  charts: Statecharts,\n  state: { states: Array<(string | number)[]> }\n) {\n  const transitions: Array<{index: number, target?: string}> = []\n\n  state.states.forEach((statePath, index) => {\n    const path = statePath.slice()\n\n    while (path.length) {\n      const target = getStateTarget(charts, path)\n\n      if (target.on && \n        target.on[actionName] === null\n      ) {\n        transitions.push({index})\n        return\n      }\n\n      if (target.on && typeof target.on[actionName] === 'string' && !transitions.find((transition) => transition.target === target.on[actionName])) {\n        transitions.push({index, target: target.on[actionName]})\n        return\n      }\n\n      if (target.on && target.on[actionName] && target.on[actionName].target && !transitions.find((transition) => transition.target === target.on[actionName].target) && target.on[actionName].condition(state)) {\n        transitions.push({\n          index,\n          target: target.on[actionName].target\n        })\n        return\n      }\n\n      path.pop()\n    }\n  })\n\n  return transitions\n}\n\nfunction getCanTransitionActions(actions, charts, state) {\n  return Object.keys(actions || {}).reduce((aggr, key) => {\n    aggr[key] = Boolean(getActionTransitions(key, charts, state).length)\n\n    return aggr\n  }, {})\n}\n\nfunction getMatchPaths(matches, paths: Array<string[]> = [[]]) {\n  const initialPath = paths[paths.length - 1].slice()\n\n  Object.keys(matches).forEach((matchKey, index) => {\n    const match = matches[matchKey]\n  \n    if (index > 0) {\n      paths.push(initialPath.slice())\n    }\n\n    paths[paths.length - 1].push(matchKey)\n\n    if (typeof match !== 'boolean') {\n      getMatchPaths(match, paths)\n    }\n  })\n\n  return paths\n}\n\nfunction getInitialStates(charts: Statecharts, paths: Array<string[]> = [[]]) {\n  const initialPath = paths[paths.length - 1].slice()\n\n  Object.keys(charts).forEach((chartKey, index) => {\n    const chart = charts[chartKey]\n  \n    if (index > 0) {\n      paths.push(initialPath.slice())\n    }\n\n    paths[paths.length - 1].push(chartKey)\n    paths[paths.length - 1].push(chart.initial as string)\n\n    const nestedChart = chart.states[chart.initial as string].chart\n    if (nestedChart && isRootChart(nestedChart)) {\n      getInitialStates({\n        [CHART]: nestedChart\n      } as Statecharts, paths)\n    } else if (nestedChart) {\n      getInitialStates(nestedChart as Statecharts, paths)\n    }\n  })\n\n  return paths\n}\n\nfunction createNewStatePath(\n  currentStates: Array<string[]>,\n  transitionStates: string[],\n  charts: Statecharts,\n  index: number\n) {\n  const newStatePath: string[] = []\n  let x = 0\n  let transitionState = transitionStates.shift()\n\n  // Keep existing state before transition\n  while (!transitionState && transitionStates.length) {\n    newStatePath.push(currentStates[index][x])\n    transitionState = transitionStates.shift()\n    x++\n  }\n\n  if (!transitionState) {\n    return currentStates[index]\n  }\n\n  // Add the new transition\n  newStatePath.push(transitionState)\n\n  const stateTarget = getStateTarget(charts, newStatePath)\n\n  // If we have more nested state, go grab the initial states\n  if (stateTarget.chart) {\n    return newStatePath.concat(getInitialStates(stateTarget.chart)[index])\n  }\n\n  return newStatePath\n}\n\nfunction getTarget(source, path) {\n  return path.reduce((aggr, key) => aggr[key], source)\n}\n\nfunction getStateTarget(charts, path) {\n  return path.reduce(\n    (aggr, key, index) => {\n      const isChart = index % 2\n\n      if (!isChart) {\n        return aggr[key]\n      }\n\n      if (index === path.length - 1) {\n        return aggr.states[key]\n      }\n\n      return aggr.states[key].chart\n    },\n    charts\n  )\n}\n\ntype Match<T extends Statecharts | Statechart<any, any>> = T extends Statecharts ? {\n  [I in keyof T]?: {\n    [S in keyof T[I][\"states\"]]?: T[I][\"states\"][S][\"chart\"] extends void ? boolean : boolean | Match<T[I][\"states\"][S][\"chart\"]>\n  }\n} : T extends Statechart<any, any> ? {\n  [S in keyof T[\"states\"]]?: T[\"states\"][S][\"chart\"] extends void ? boolean : boolean | Match<T[\"states\"][S][\"chart\"]>\n} : never\n\n\nexport function statechart<C extends IConfiguration, Charts extends Statecharts | Statechart<any, any>>(\n  config: C,\n  chartDefinition: Charts\n): IConfig<{\n  onInitialize: C['onInitialize']\n  state: C['state'] & {\n    states: Array<(string | number)[]>\n    actions: { [N in keyof C['actions']]: boolean }\n    matches: IDerive<any, any, (match: Match<Charts>) => boolean>\n  }\n  actions: C['actions']\n  effects: C['effects']\n}> & {\n  onInitialize: C['onInitialize']\n} {\n  let currentInstance\n\n  const charts = forceNestedCharts(chartDefinition)\n  const actions = config.actions || {}\n  const state = config.state || {}\n\n  if (config.state && (config.state as any).states) {\n    throw new Error(\n      `Overmind statecharts: You have already defined the state \"states\" in your configuration. Statecharts needs this, please rename it`\n    )\n  }\n\n  if (config.state && (config.state as any).matches) {\n    throw new Error(\n      `Overmind statecharts: You have already defined the state \"matches\" in your configuration. Statecharts needs this, please rename it`\n    )\n  }\n\n  let currentTransitionAction: string | null = null\n\n  return {\n    onInitialize: ((context, instance) => {\n      if (config.onInitialize) {\n        config.onInitialize(context, instance)\n      }\n      \n      currentInstance = instance\n      const stateTarget = getTarget(\n        context.state,\n        context.execution.namespacePath\n      )\n      const actionsTarget = getTarget(\n        context.actions,\n        context.execution.namespacePath\n      )\n\n      const statePaths = stateTarget.states.slice()\n\n      // Run entry actions of initial state\n      statePaths.forEach((statePath) => {\n        const state = statePath.slice()\n        while (state.length) {\n          const target = getStateTarget(charts, state)\n\n          if (config.actions && config.actions[target.entry]) {\n            actionsTarget[ACTIONS][target.entry](context)\n          }\n\n          state.pop()\n        }\n      })\n\n      if (process.env.NODE_ENV === 'development' && instance.devtools) {\n        instance.devtools.send({\n          type: 'chart',\n          data: {\n            path: context.execution.namespacePath,\n            states: getInitialStates(charts),\n            charts: charts,\n            actions: getCanTransitionActions(actions, charts, stateTarget),\n          },\n        })\n      }\n    }) as any,\n    state: Object.assign(state, {\n      states: getInitialStates(charts),\n      actions: ((state) => getCanTransitionActions(actions, charts, state)) as any,\n      matches: (state) => (match) => {\n        const matchPaths = getMatchPaths(match)\n        const statesWithoutRootChartIndicator = state.states.map((statePath) => statePath.filter((path) => path !== CHART))\n\n        for (let x = 0; x < matchPaths.length; x++) {\n          const matchPath = matchPaths[x]\n          const shouldMatch = matchPath.reduce((aggr, key) => aggr[key], match)\n          const hasMatch = statesWithoutRootChartIndicator.reduce((aggr, statePath) => {\n            if (aggr) {\n              return aggr\n            }\n\n            return statePath.reduce((aggr, path, index) => {\n              if (!aggr) {\n                return aggr\n              }\n\n              return path === matchPath[index]\n            }, true)\n          }, false)\n\n          if (shouldMatch !== hasMatch) {\n            return false\n          }\n        }\n\n        return true\n      },\n    }),\n    actions: Object.keys(actions).reduce((aggr, key) => {\n      aggr[key] = pipe(\n        map(function getTransition({ state, execution }: any, payload) {\n          const stateTarget = getTarget(state, execution.namespacePath)\n          const canTransition = stateTarget.actions[key]\n          if (currentTransitionAction && !canTransition) {\n            console.warn(`Overmind Statecharts: Transition action \"${currentTransitionAction}\" is calling transition action \"${key}\" synchronously. The previous transition is not done yet and \"${key}\" will be ignored. Consider calling it asynchronously `)\n          } else if (!canTransition && process.env.NODE_ENV === 'development') {\n            console.warn(`You tried to call action \"${key}\", but it was blocked by the statechart. You are not supposed to call this action in the current state of the chart. This warning only appear during development`)\n          }\n\n          return {\n            canTransition,\n            payload,\n          }\n        }),\n        filter(function canTransition(_, payload) {\n          return payload.canTransition\n        }),\n        mutate(function runAction(context: any, { payload }) {\n          const stateTarget = getTarget(\n            context.state,\n            context.execution.namespacePath\n          )\n          const actionsTarget = getTarget(\n            context.actions,\n            context.execution.namespacePath\n          )\n          const transitionActions = getActionTransitions(key, charts, stateTarget)\n\n          // If there are no new transition target, just drop moving on, just run the action\n          if (!transitionActions.some((transitionAction) => transitionAction.target)) {\n            if (config.actions) {\n              return actionsTarget[ACTIONS][key](payload)\n            }\n            return\n          }\n\n          const exitActions: string[] = []\n          const entryActions: string[] = []\n          const newStates: Array<string[]> = []\n\n          transitionActions.forEach((transitionAction) => {\n            // It is an action that does not cause a transition\n            if (!transitionAction.target) {\n              return\n            }\n            \n            const currentStatePath = stateTarget.states[transitionAction.index].slice()\n            const stateTransitions = currentStatePath.map(() => null)\n\n            // Build new transition path\n            while (currentStatePath.length) {\n              const target = getStateTarget(charts, currentStatePath)\n\n              // Collect the new transition state\n              if (target.on && target.on[key]) {\n                stateTransitions[currentStatePath.length - 1] =\n                  target.on[key].target || target.on[key]\n              }\n\n              currentStatePath.pop()\n            }\n\n            const newStatePath = createNewStatePath(\n              stateTarget.states,\n              stateTransitions,\n              charts,\n              transitionAction.index\n            )\n\n            // Go down old path and trigger exits where the state has changed\n            const traverseOldPath = stateTarget.states[transitionAction.index].slice()\n\n            while (traverseOldPath.length) {\n              const target = getStateTarget(charts, traverseOldPath)\n\n              if (\n                target.exit &&\n                newStatePath[traverseOldPath.length - 1] !==\n                traverseOldPath[traverseOldPath.length - 1]\n              ) {\n                \n                exitActions.push(target.exit)\n              }\n\n              traverseOldPath.pop()\n            }\n\n            newStates.push(newStatePath.slice())\n\n            // Go down new path and trigger any entry on new states\n            const traverseNewPath = newStatePath.slice()\n            while (traverseNewPath.length) {\n              const target = getStateTarget(charts, traverseNewPath)\n\n              if (\n                target.entry &&\n                newStatePath[traverseNewPath.length - 1] !==\n                stateTarget.states[transitionAction.index][traverseNewPath.length - 1]\n              ) {\n                entryActions.push(target.entry)\n              }\n\n              traverseNewPath.pop()\n            }\n\n          })\n          \n          // Run exits\n          exitActions.forEach((exitAction) => {\n            if (config.actions) {\n              actionsTarget[ACTIONS][exitAction](payload)\n            }  \n          })\n          \n          currentTransitionAction = key\n          let actionResult;\n          if (config.actions) {\n            actionResult = actionsTarget[ACTIONS][key](payload)\n          }\n\n          currentTransitionAction = null\n          \n          // Transition to new state\n          stateTarget.states = newStates\n          \n          // Run entry actions          \n          entryActions.forEach((entryAction) => {\n            if (config.actions) {\n              actionsTarget[ACTIONS][entryAction](payload)\n            }  \n          })\n\n          \n\n          if (process.env.NODE_ENV === 'development' && currentInstance.devtools) {\n            currentInstance.devtools.send({\n              type: 'chart',\n              data: {\n                path: context.execution.namespacePath,\n                states: stateTarget.states,\n                charts: charts,\n                actions: getCanTransitionActions(\n                  config.actions,\n                  charts,\n                  stateTarget\n                ),\n              },\n            })\n          }\n\n          return actionResult\n        })\n      )\n\n      return aggr\n    }, {\n      [ACTIONS]: actions\n    }),\n    effects: config.effects || {},\n  }\n}"]}