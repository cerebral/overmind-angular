import { IConfig, IConfiguration, IDerive } from '../';
export interface Statechart<C extends IConfiguration, S extends {
    [state: string]: Statecharts | Statechart<any, any> | void;
}> {
    initial: keyof S;
    states: {
        [N in keyof S]: {
            entry?: keyof C['actions'];
            exit?: keyof C['actions'];
            chart?: S[N];
            on?: {
                [N in keyof C['actions']]?: keyof S | {
                    target: keyof S;
                    condition: (state: C['state']) => boolean;
                } | null;
            };
        };
    };
}
interface Statecharts {
    [id: string]: Statechart<any, any>;
}
declare type Match<T extends Statecharts | Statechart<any, any>> = T extends Statecharts ? {
    [I in keyof T]?: {
        [S in keyof T[I]["states"]]?: T[I]["states"][S]["chart"] extends void ? boolean : boolean | Match<T[I]["states"][S]["chart"]>;
    };
} : T extends Statechart<any, any> ? {
    [S in keyof T["states"]]?: T["states"][S]["chart"] extends void ? boolean : boolean | Match<T["states"][S]["chart"]>;
} : never;
export declare function statechart<C extends IConfiguration, Charts extends Statecharts | Statechart<any, any>>(config: C, chartDefinition: Charts): IConfig<{
    onInitialize: C['onInitialize'];
    state: C['state'] & {
        states: Array<(string | number)[]>;
        actions: {
            [N in keyof C['actions']]: boolean;
        };
        matches: IDerive<any, any, (match: Match<Charts>) => boolean>;
    };
    actions: C['actions'];
    effects: C['effects'];
}> & {
    onInitialize: C['onInitialize'];
};
export {};
