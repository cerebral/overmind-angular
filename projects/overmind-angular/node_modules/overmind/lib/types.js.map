{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":";;AAEA,mCAAqC;AAErC;GACG;AACH,iDAA2C;AAAlC,oCAAA,SAAS,CAAA","sourcesContent":["import { Overmind } from './'\nimport { ResolveActions, ResolveState } from './internalTypes'\nimport { IS_OPERATOR } from './utils'\n\n/** ===== PUBLIC API\n */\nexport { EventType } from './internalTypes'\n\nexport type IConfiguration = {\n  onInitialize?: any\n  state?: {}\n  effects?: {}\n  actions?: {}\n}\n\nexport type IState = {\n  [key: string]:\n    | IState\n    | string\n    | IDerive<any, any, any>\n    | number\n    | boolean\n    | object\n    | null\n    | undefined\n}\n\n\nexport interface IConfig<ThisConfig extends IConfiguration> {\n  state: ThisConfig['state'] & {}\n  actions: ThisConfig['actions'] & {}\n  effects: ThisConfig['effects'] & {}\n}\n\nexport type IContext<ThisConfig extends IConfiguration> = {\n  state: ResolveState<ThisConfig['state']>\n  actions: ResolveActions<ThisConfig['actions']>\n  effects: ThisConfig['effects']\n  revertable: (mutationsCallback: () => any) => () => void\n}\n\nexport interface IReaction<ThisConfig extends IConfiguration> {\n  <O>(\n    stateCallback: (state: ResolveState<ThisConfig['state']>) => O,\n    updateCallback: (value: O) => void,\n    options?: {\n      nested?: boolean\n      immediate?: boolean\n    }\n  ): () => void\n}\n\nexport interface IAction<\n  ThisConfig extends IConfiguration,\n  Value,\n  ReturnValue = void | Promise<void>\n> {\n  <InferredReturnValue extends ReturnValue>(\n    context: IContext<ThisConfig>,\n    value: Value\n  ): ReturnValue extends Promise<any>\n    ? ReturnValue\n    : InferredReturnValue | ReturnValue\n}\n\n// We do not type operators as their low level implementation, but rather\n// how it is consumed by the developer\nexport interface IOperator<\n  ThisConfig extends IConfiguration,\n  Input,\n  Output = Input\n> {\n  (context: IContext<ThisConfig>, value: Input): Output\n  [IS_OPERATOR]: true\n}\n\nexport type IDerive<\n  ThisConfig extends IConfiguration,\n  Parent extends IState,\n  Value\n> = (\n  parent: ResolveState<Parent>,\n  state: ResolveState<ThisConfig['state']>\n) => Value\n\nexport interface IOnInitialize<ThisConfig extends IConfiguration> {\n  (context: IContext<ThisConfig>, value: Overmind<ThisConfig>): void\n}\n"]}