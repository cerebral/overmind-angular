"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const is_plain_obj_1 = tslib_1.__importDefault(require("is-plain-obj"));
const proxy_state_tree_1 = require("proxy-state-tree");
exports.IS_TEST = process.env.NODE_ENV === 'test';
exports.IS_OPERATOR = Symbol('operator');
exports.ORIGINAL_ACTIONS = Symbol('origina_actions');
exports.EXECUTION = Symbol('execution');
exports.MODE_DEFAULT = Symbol('MODE_DEFAULT');
exports.MODE_TEST = Symbol('MODE_TEST');
exports.MODE_SSR = Symbol('MODE_SSR');
class MockedEventEmitter {
    emit() { }
    emitAsync() { }
    on() { }
    once() { }
    addListener() { }
}
exports.MockedEventEmitter = MockedEventEmitter;
exports.json = (obj) => {
    return deepCopy(obj && obj[proxy_state_tree_1.IS_PROXY] ? obj[proxy_state_tree_1.VALUE] : obj);
};
function isPromise(maybePromise) {
    return (maybePromise instanceof Promise ||
        (maybePromise &&
            typeof maybePromise.then === 'function' &&
            typeof maybePromise.catch === 'function'));
}
exports.isPromise = isPromise;
function processState(state) {
    return Object.keys(state).reduce((aggr, key) => {
        if (key === '__esModule') {
            return aggr;
        }
        const originalDescriptor = Object.getOwnPropertyDescriptor(state, key);
        if (originalDescriptor && 'get' in originalDescriptor) {
            Object.defineProperty(aggr, key, originalDescriptor);
            return aggr;
        }
        const value = state[key];
        if (is_plain_obj_1.default(value)) {
            aggr[key] = processState(value);
        }
        else {
            Object.defineProperty(aggr, key, originalDescriptor);
        }
        return aggr;
    }, {});
}
exports.processState = processState;
function getFunctionName(func) {
    return func.name || func.displayName || '';
}
exports.getFunctionName = getFunctionName;
function deepCopy(obj) {
    if (is_plain_obj_1.default(obj)) {
        return Object.keys(obj).reduce((aggr, key) => {
            if (key === '__esModule') {
                return aggr;
            }
            const originalDescriptor = Object.getOwnPropertyDescriptor(obj, key);
            const isAGetter = originalDescriptor && 'get' in originalDescriptor;
            const value = obj[key];
            if (isAGetter) {
                Object.defineProperty(aggr, key, originalDescriptor);
            }
            else {
                aggr[key] = deepCopy(value);
            }
            return aggr;
        }, {});
    }
    else if (Array.isArray(obj)) {
        return obj.map((item) => deepCopy(item));
    }
    return obj;
}
exports.deepCopy = deepCopy;
function mergeState(originState, oldState, nextState) {
    function merge(origin, old, next) {
        if (is_plain_obj_1.default(old) && is_plain_obj_1.default(next)) {
            const newBranch = {};
            const keys = Object.keys(old).concat(Object.keys(next));
            for (let key of keys) {
                newBranch[key] = merge(origin[key], old[key], next[key]);
            }
            return newBranch;
        }
        if (typeof next === 'function') {
            return next;
        }
        // We return the existing array, as arrays are typically
        // mutated, not set with new values as initial state
        if (Array.isArray(old) && Array.isArray(next)) {
            return old;
        }
        // If we have changed a state from origin, keep that
        // changed state
        if (next === origin && old !== origin) {
            return old;
        }
        return next;
    }
    return merge(originState, oldState, nextState);
}
exports.mergeState = mergeState;
function getActionPaths(actions = {}, currentPath = []) {
    return Object.keys(actions).reduce((aggr, key) => {
        if (typeof actions[key] === 'function') {
            return aggr.concat(currentPath.concat(key).join('.'));
        }
        return aggr.concat(getActionPaths(actions[key], currentPath.concat(key)));
    }, []);
}
exports.getActionPaths = getActionPaths;
function createActionsProxy(actions, cb) {
    return new Proxy(actions, {
        get(target, prop) {
            if (prop === exports.ORIGINAL_ACTIONS) {
                return actions;
            }
            if (typeof target[prop] === 'function') {
                return cb(target[prop]);
            }
            if (!target[prop]) {
                return undefined;
            }
            return createActionsProxy(target[prop], cb);
        },
    });
}
exports.createActionsProxy = createActionsProxy;
//# sourceMappingURL=utils.js.map